(function() {

    "use strict";


    var findById = function*(typeDefinition, id, ceramic, db) {
        var query = db.setRowId({}, id);
        return yield* findOne(typeDefinition, query, {}, ceramic, db);
    };



    var find = function*(typeDefinition, query, p1, p2, p3) {
        var options, ceramic, db;

        if (arguments.length === 4) {
            options = null;
            ceramic = p1;
            db = p2;
        } else {
            options = p1;
            ceramic = p2;
            db = p3;
        }

        var items = yield* db.find(typeDefinition.collection, query, options);
        if (items.length) {
            var results = [];
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                results.push(yield* ceramic.constructModel(item, typeDefinition, { systemFields: ["__updateTimestamp"] }));
            }
            return results;
        } else {
            return [];
        }
    };


    var findOne = function*(typeDefinition, query, p1, p2, p3) {
        var options, ceramic, db;

        if (arguments.length === 4) {
            options = null;
            ceramic = p1;
            db = p2;
        } else {
            options = p1;
            ceramic = p2;
            db = p3;
        }

        var result = yield* db.findOne(typeDefinition.collection, query, options);
        if (result) {
            return yield* ceramic.constructModel(result, typeDefinition, { systemFields: ["__updateTimestamp"] });
        }
    };


    var count = function*(typeDefinition, query, ceramic, db) {
        return yield* db.count(typeDefinition.collection, query);
    };


    var destroyAll = function*(typeDefinition, query, ceramic, db) {
        if (typeof typeDefinition.canDestroyAll === "function" && typeDefinition.canDestroyAll(query)) {
            return yield* db.remove(typeDefinition.collection, query);
        } else {
            throw new Error("Call to destroyAll must pass safety checks on query.");
        }
    };


    var save = function*(record, typeDefinition, ceramic, db) {
        if (typeDefinition.autoGenerated) {
            for (var fieldName in typeDefinition.autoGenerated) {
                var def = typeDefinition.autoGenerated[fieldName];
                switch (def.event) {
                    case 'created':
                        if (!db.getRowId(record)) {
                            record[fieldName] = Date.now();
                        }
                        break;
                    case 'updated':
                        record[fieldName] = Date.now();
                }
            }
        }

        var errors = yield* ceramic.validate(record, typeDefinition);

        if (!errors.length) {
            if (db.getRowId(record) && (typeDefinition.concurrency === 'optimistic' || !typeDefinition.concurrency)) {
                var _item = yield* db.findOne(typeDefinition.collection, db.setRowId({}, db.getRowId(record)));
                if (_item.__updateTimestamp !== record.__updateTimestamp) {
                    throw new Error("Update timestamp mismatch. Was " + _item.__updateTimestamp + " in saved, " + record.__updateTimestamp + " in new.");
                }
            }

            record.__updateTimestamp = Date.now();

            var result;
            if (!db.getRowId(record)) {
                if (typeDefinition.logging && typeDefinition.logging.onInsert) {
                    var insertEvent = {
                        type: typeDefinition.logging.onInsert,
                        data: record
                    };
                    yield* db.insert('events', insertEvent);
                }
                result = yield* db.insert(typeDefinition.collection, record);
                db.setRowId(record, result.insertedId);
            } else {
                if (typeDefinition.logging && typeDefinition.logging.onUpdate) {
                    var updateEvent = {
                        type: typeDefinition.logging.onUpdate,
                        data: record
                    };
                    db.insert('events', updateEvent);
                }
                var query = db.setRowId({}, db.getRowId(record));
                yield* db.update(typeDefinition.collection, query, record);
            }
        } else {
            var details = "Cannot save " + typeDefinition.name;
            details = details + ": " + (errors.join(', ')) + ".";
            throw new Error(details);
        }
    };


    var destroy = function*(record, typeDefinition, ceramic, db) {
        var query = db.setRowId({}, db.getRowId(record));
        return db.remove(typeDefinition.collection, query);
    };


    var link = function*(record, typeDef, name, ceramic, db) {
        var query, result;

        var link = typeDef.links[name];
        var otherTypeDef = yield* ceramic.getTypeDefinition(link.type);
        if (link.key) {
            //#this handles keys of the type [{credentialId: _id}, {username: username}]
            if (typeof link.key === 'string') {
                switch (typeDef.schema.properties[link.key].type) {
                    case 'string':
                        return yield* findById(typeDefinition, record[link.key], ceramic, db);
                    case 'array':
                        throw new Error("Array keys are not implemented");
                }
            } else if (link.key instanceof Array) {
                query = {};
                link.key.forEach(function(key) {
                    for(var keyFrom of key) {
                        var keyTo = key[keyFrom];
                        query[keyTo] = record[keyFrom];
                    }
                }, record);
                return yield* findOne(otherTypeDef, query, ceramic, db);
            } else {
                throw new Error("Cannot parse this key");
            }

        } else if (link.field) {
            //handles keys of the type [{credentialId: _id}, {username: username}]
            if (typeof link.field === 'string') {
                switch (otherTypeDef.schema.properties[link.field].type) {
                    case 'string':
                        var params = {};
                        params["" + link.field] = db.getRowId(record);
                        result = yield* find(otherTypeDef, params, ceramic, db);
                        if (link.multiplicity === "one") {
                            if (result.length) {
                                return result[0];
                            }
                        } else {
                            return result;
                        }
                        break;
                    case 'array':
                        throw new Error("Array keys are not implemented");
                }
            } else if (link.field instanceof Array) {
                query = {};
                link.field.forEach(function(field) {
                    for(var fieldFrom of field) {
                        var fieldTo = field[fieldFrom];
                        query[fieldFrom] = record[fieldTo];
                    }
                }, record);
                return yield* findOne(otherTypeDef, query, ceramic, db);
            } else {
                throw new Error("Cannot parse this key");
            }

        } else {
            throw new Error("Invalid link " + name + " in " + typeDef.name);
        }
    };


    module.exports = {
        findById: findById,
        find: find,
        findOne: findOne,
        count: count,
        destroyAll: destroyAll,
        save: save,
        destroy: destroy,
        link: link
    };

})();
