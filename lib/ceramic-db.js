(function() {

    "use strict";


    var getRowId = function(item, entitySchema) {
        var rowId = entitySchema.rowId || "_id";
        return item[rowId] ? item[rowId]: undefined;
    };


    var setRowId = function(item, id, entitySchema) {
        var rowId = entitySchema.rowId || "_id";
        item[rowId] = id;
        return item;
    };


    var getIdQuery = function(item, entitySchema) {
        var rowId = entitySchema.rowId || "_id";
        var query = {};
        query[rowId] = item[rowId];
        return query;
    };


    var constructEntity = function*(item, entitySchema, ceramic, db) {
        var id = getRowId(item, entitySchema);
        var result = yield* ceramic.constructEntity(item, entitySchema, { additionalProperties: ["__updateTimestamp"] });
        setRowId(result, id, entitySchema);
        return result;
    };


    var findById = function*(entitySchema, id, ceramic, db) {
        if (typeof id === "string")
            id = db.ObjectID(id);
        var query = setRowId({}, id, entitySchema);
        return yield* findOne(entitySchema, query, {}, ceramic, db);
    };


    var find = function*(entitySchema, query, p1, p2, p3) {
        var options, ceramic, db;

        if (arguments.length === 4) {
            options = [];
            ceramic = p1;
            db = p2;
        } else {
            options = p1;
            ceramic = p2;
            db = p3;
        }

        var collection = yield* db.collection(entitySchema.collection);
        var cursor = yield* collection.find(query, options);

        /*
            options are of the form
            [
                ["sort", {.....}],
                ["limit", {.....}],
                ["skip", {.....}]
            ]
        */
        options.forEach(function(option) {
            var optionName = option[0];
            var optionVal = option[1];
            switch (optionName) {
                case "sort":
                    cursor.sort(optionVal);
                    break;
                case "skip":
                    cursor.skip(optionVal);
                    break;
                case "limit":
                    cursor.limit(optionVal);
                    break;
            }
        });

        var items = yield* cursor.toArray();

        if (items.length) {
            var results = [];
            for (var i = 0; i < items.length; i++) {
                var item = items[i];
                results.push(yield* constructEntity(item, entitySchema, ceramic, db));
            }
            return results;
        } else {
            return [];
        }
    };


    var findOne = function*(entitySchema, query, p1, p2, p3) {
        var options, ceramic, db;

        if (arguments.length === 4) {
            options = {};
            ceramic = p1;
            db = p2;
        } else if (arguments.length === 5) {
            options = p1;
            ceramic = p2;
            db = p3;
        } else {
            throw new Error("Invalid number of arguments. Use (schema, query, ceramic, db) or (schema, query, options, ceramic, db).");
        }

        var collection = yield* db.collection(entitySchema.collection);
        var result = yield* collection.findOne(query, options);
        if (result) {
            return yield* constructEntity(result, entitySchema, ceramic, db);
        }
    };


    var count = function*(entitySchema, query, ceramic, db) {
        var collection = yield* db.collection(entitySchema.collection);
        return yield* collection.count(query);
    };


    var _delete = function*(record, entitySchema, ceramic, db) {
        var collection = yield* db.collection(entitySchema.collection);
        var query = getIdQuery(record, entitySchema);
        return yield* collection.deleteOne(query);
    };


    var deleteMany = function*(entitySchema, query, ceramic, db) {
        if (typeof entitySchema.canDestroyAll === "function" && entitySchema.canDestroyAll(query)) {
            var collection = yield* db.collection(entitySchema.collection);
            return yield* collection.deleteMany(query);
        } else {
            throw new Error("Call to destroyAll must pass safety checks on query.");
        }
    };


    var save = function*(record, entitySchema, ceramic, db) {
        if (entitySchema.autoGenerated) {
            for (var fieldName in entitySchema.autoGenerated) {
                var def = entitySchema.autoGenerated[fieldName];
                switch (def.event) {
                    case 'created':
                        if (!getRowId(record, entitySchema)) {
                            record[fieldName] = Date.now();
                        }
                        break;
                    case 'updated':
                        record[fieldName] = Date.now();
                }
            }
        }

        var errors = yield* ceramic.validate(record, entitySchema);

        if (!errors) {
            var collection = yield* db.collection(entitySchema.collection);
            var eventsCollection = yield* db.collection("__events");
            if (getRowId(record, entitySchema) && (entitySchema.concurrency === 'optimistic' || !entitySchema.concurrency)) {
                var _item = yield* collection.findOne(getIdQuery(record, entitySchema));
                if (_item.__updateTimestamp !== record.__updateTimestamp) {
                    throw new Error("Update timestamp mismatch. Was " + _item.__updateTimestamp + " in saved, " + record.__updateTimestamp + " in new.");
                }
            }

            record.__updateTimestamp = Date.now();

            var result;
            if (!getRowId(record, entitySchema)) {
                if (entitySchema.logging && entitySchema.logging.onInsert) {
                    var insertEvent = {
                        type: entitySchema.logging.onInsert,
                        data: record
                    };

                    yield* eventsCollection.insertOne(insertEvent);
                }
                result = yield* collection.insertOne(record);
                setRowId(record, result.insertedId, entitySchema);
            } else {
                if (entitySchema.logging && entitySchema.logging.onUpdate) {
                    var updateEvent = {
                        type: entitySchema.logging.onUpdate,
                        data: record
                    };
                    eventsCollection.insertOne(updateEvent);
                }
                var query = getIdQuery(record, entitySchema);
                yield* collection.updateOne(entitySchema.collection, query, record);
            }
        } else {
            var details = "Cannot save " + entitySchema.schema.id;
            details = details + ": " + JSON.stringify(errors);
            throw new Error(details);
        }
    };


    var link = function*(record, typeDef, name, ceramic, db) {
        var query, result;

        var link = typeDef.links[name];
        var otherEntitySchema = yield* ceramic.getEntitySchema(link.type);
        if (link.key) {
            //#this handles keys of the type [{credentialId: _id}, {username: username}]
            if (typeof link.key === 'string') {
                switch (typeDef.schema.properties[link.key].type) {
                    case 'string':
                        return yield* findById(otherEntitySchema, record[link.key], ceramic, db);
                    case 'array':
                        throw new Error("Array keys are not implemented");
                }
            } else if (link.key instanceof Array) {
                query = {};
                link.key.forEach(function(key) {
                    for(var keyFrom of key) {
                        var keyTo = key[keyFrom];
                        query[keyTo] = record[keyFrom];
                    }
                }, record);
                return yield* findOne(otherEntitySchema, query, ceramic, db);
            } else {
                throw new Error("Cannot parse this key");
            }

        } else if (link.field) {
            //handles keys of the type [{credentialId: _id}, {username: username}]
            if (typeof link.field === 'string') {
                switch (otherEntitySchema.schema.properties[link.field].type) {
                    case 'string':
                        var params = {};
                        params["" + link.field] = getRowId(record, entitySchema);
                        result = yield* find(otherEntitySchema, params, ceramic, db);
                        if (link.multiplicity === "one") {
                            if (result.length) {
                                return result[0];
                            }
                        } else {
                            return result;
                        }
                        break;
                    case 'array':
                        throw new Error("Array keys are not implemented");
                }
            } else if (link.field instanceof Array) {
                query = {};
                link.field.forEach(function(field) {
                    for(var fieldFrom of field) {
                        var fieldTo = field[fieldFrom];
                        query[fieldFrom] = record[fieldTo];
                    }
                }, record);
                return yield* findOne(otherEntitySchema, query, ceramic, db);
            } else {
                throw new Error("Cannot parse this key");
            }

        } else {
            throw new Error("Invalid link " + name + " in " + typeDef.name);
        }
    };


    module.exports = {
        findById: findById,
        find: find,
        findOne: findOne,
        count: count,
        deleteMany: deleteMany,
        save: save,
        delete: _delete,
        link: link
    };

})();
